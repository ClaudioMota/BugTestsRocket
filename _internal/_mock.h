// This content is part of test.h
// Mock functionalities

typedef struct FunctionMock FunctionMock;
typedef struct FunctionDescriptor FunctionDescriptor;

struct FunctionMock
{
  bool set;
  int calls;
  void* mockPointer;
  const char* name;
};

struct FunctionDescriptor
{
  char returnType[32];
  char name[_BTR_MAX_NAME_SIZE];
  char args[_BTR_MAX_NAME_SIZE];
};

int _writeArgs(FILE* file, char* args)
{
  int argsCount = 0;
  int argsSize = strlen(args);
  char arg[argsSize + 1];
  int a = 0;
  for(int i = 0; i <= argsSize; i++)
  {
    if(!isspace(args[i]) || !args[i])
    {
      if(args[i] == '\0' || args[i] == ',')
      {
        if(a > 0)
        {
          arg[a] = '\0';
          if(argsCount > 0) fprintf(file, ",");
          fprintf(file, "%s a%i", arg, argsCount++);
        }
        a = 0;
      }
      else
        arg[a++] = args[i];
    }
  }
  return argsCount;
}

void _getMockedName(char* output, char* functioName)
{
  strcpy(output, "🐛");
  strcat(output, functioName);
  strcat(output, "🚀");
}

extern void (*onFail)(char* file, int line, char* expr);

FunctionMock* _getMock(char* file, int line, char* functionName, FunctionMock* mocks)
{
  FunctionMock* mock = 0;
  for(int i = 0; mocks[i].set; i++)
  {
    if(strcmp(mocks[i].name, functionName) == 0)
    {
      mock = &mocks[i];
      break;
    }
  }

  char message[_BTR_MAX_NAME_SIZE];
  strcpy(message, "Could not mock function ");
  strcat(message, functionName);
  if(!mock) onFail(file, line, message);

  return mock;
}

void _mock(char* file, int line, char* functionName, void* function, FunctionMock* mocks)
{
  FunctionMock* mock = _getMock(file, line, functionName, mocks);
  if(mock) *((void**)mock->mockPointer) = function;
}

bool _createMockFile(char* mockFilePath, int functionCount, FunctionDescriptor* functions)
{
  FILE* file = fopen(mockFilePath, "wb");
  if(!file) return false;

  fprintf(file, "// This header file was generated by BugTestsRocket test framework\n");
  fprintf(file, "// It must be included after test.h and any eventual required typedefs\n");
  fprintf(file, "#ifdef BUG_TESTS_ROCKET_TEST_HEADER\n");
  fprintf(file, "#ifdef __cplusplus\nextern \"C\"{\n"
                "#define _BTR_CONVERT(what, to) reiterpret_cast<to>(what)\n"
                "#else\n"
                "#define _BTR_CONVERT(what, to) ((to)(what))\n"
                "#endif\n"); 

  for(int i = 0; i < functionCount; i++)
  {
    char mockedName[_BTR_MAX_NAME_SIZE];
    _getMockedName(mockedName, functions[i].name);
    fprintf(file, "%s %s(%s);\n", functions[i].returnType, mockedName, functions[i].args);
    fprintf(file, "void* _mocked_%s = _BTR_CONVERT(%s, void*);\n", functions[i].name, mockedName);
  }
  for(int i = 0; i < functionCount; i++)
  {
    fprintf(file, "%s %s(", functions[i].returnType, functions[i].name);
    int argsCount = _writeArgs(file, functions[i].args);
    fprintf(file, "){ _mocks[%i].calls++; return _BTR_CONVERT(_mocked_%s, %s (*)(%s))(",
      i, functions[i].name, functions[i].returnType, functions[i].args);
    for(int a = 0; a < argsCount; a++)
      if(a)
        fprintf(file, ", a%i", a);
      else
        fprintf(file, "a%i", a);
    fprintf(file, "); }\n");
  }
  fprintf(file, "FunctionMock _mocks[] = {\n");
  for(int i = 0; i < functionCount; i++)
  {
    fprintf(file, "  {true, (int)0, (void*)&_mocked_%s, \"%s\"},\n", functions[i].name, functions[i].name);
  }
  fprintf(file, "  {false, (int)0, (void*)0, \"\"}\n};\n");
  fprintf(file, "#ifdef __cplusplus\n}\n#endif\n#endif\n"); 

  fclose(file);
  return true;
}

bool createMocks(char* libPath, char* mockableLibPath, char* mockFilePath, int functionCount, FunctionDescriptor* functions)
{
  bool ret = true;
 
  _StaticLib lib;

  if(_staticLibRead(&lib, libPath))
  {
    for(int f = 0; f < functionCount; f++)
    {
      char mockedName[strlen(functions[f].name)+64];
      _getMockedName(mockedName, functions[f].name);
    
      for(int i = 0; i < lib.header.globalSymbolCount; i++)
        if(strcmp(lib.globalSymbols[i].name, functions[f].name) == 0)
          strcpy(lib.globalSymbols[i].name, mockedName);
    
      for(int i = 0; i < lib.fileCount; i++)
        _objectFileMockFunction(&lib.files[i], functions[f].name, mockedName);
    }
    
    ret = _staticLibWrite(&lib, mockableLibPath);
    ret &= _createMockFile(mockFilePath, functionCount, functions);
  }
  else
    ret = false;

  _staticLibFree(&lib);

  return ret;
}
